syntax = "proto3";
package flare.v1;

// Asymmetric keys are transmitted in PKCS#8 PEM container format.
// "+" denotes base64 concatenation, where a separator "|" is added, e.g,
// "tornado" + "juice" = b64_std("tornado").concat("|").concat(b64_std("juice"))

// Generic client-client message, enveloping text and profile update messages.
// [enc_message, sender_username, sender_id_pub_key, nonce, time_client] are expected to be mirrored
// from the outbound message (rpc_messaging.proto -> MessageBody)
message ConfidentialMessage {
    string enc_message = 1;         // standard base64 encoding of AES-GCM-SIV output,
                                    // ... where input plaintext is:
                                    //      serialized MessageEnvelope
                                    // ... where associated data is:
                                    //      sender username
                                    //      + sender id public key (PKCS#8 PEM)
                                    //      + 96-bit nonce:
                                    //          64 bit unix millis
                                    //          32 bit random number, or modulus counter
                                    //      + client time (untrusted time of sending, as reported by sender)
    string sender_username = 2;
    string sender_id_pub_key = 3;
    string nonce = 4;
    uint64 time_client = 5;
    uint64 time_server = 6;         // not in associated data, untrusted server-added received timestamp
}

// Generic message container, wrapping over various plaintext user-user messages
message MessageEnvelope {
    uint64 sender_counter = 1;  // Monotonically-increasing outbound message counter maintained by the sender
                                // *    the client MUST assert this monotonic increase of the outbound counter by maintaining state
                                // *    on failure, the client MUST 
                                //          *   EITHER handle the unexpected event in a way that preserves causality and restores harmony,
                                //          *   OR abort the conversation with the sender to force a re-negotiation of a shared secret
                                // *    (suggested) resolving a counter leap:
                                //          *   allow by setting the counter to match the leap,
                                //              and notifying the user (with a message-like) container the number of skipped messages
                                //          *   keeping a buffer of messages until order resolves itself, where for each leap a 
                                // *    (suggested) resolving a counter decrease:
                                //          *   IF the client maintains state about which counter values were not seen,
                                //              AND the counter was not seen
                                //              THEN the client may insert the message as normal, assuming a leap resolution
                                //          *   not acknowledging the message
                                // *    (suggested) resolving a duplicate:
                                //          *   not acknowledging the message

    bytes balloon = 2;          // Padding to obfuscate message lengths by alignment 
    oneof message {
        TextMessage text_message = 3;
        ProfileMessage profile_message = 4;
    }
}

message TextMessage {
    string text = 1;
}

message ProfileMessage {
    string display_name = 1;
    bytes image_blob = 2;
}

message ReceiptMessage {
    string target = 1;
}